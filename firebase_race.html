<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tea&O Amazing Race</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- React 18 & Babel -->
    <script src="https://unpkg.com/react@18.2.0/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.263.1",
        "firebase/app": "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js",
        "firebase/firestore": "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js"
      }
    }
    </script>

    <style>
        body { font-family: 'Outfit', sans-serif; }
        .animate-fade-in { animation: fadeIn 0.3s ease-out forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes bounceIn { 0% { transform: scale(0.9); opacity: 0; } 70% { transform: scale(1.05); opacity: 1; } 100% { transform: scale(1); } }
        .animate-bounce-in { animation: bounceIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
    </style>
</head>
<body class="bg-[#f8f9fa] text-gray-800 antialiased">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useMemo } from 'react';
        import { createRoot } from 'react-dom/client';
        import { 
            MapPin, Globe, Navigation, CloudOff, CloudLightning, RefreshCw, AlertTriangle, Loader2,
            Plus, Check, UserPlus, X, Trash2, Zap, Star, Heart, Trophy, Crown, Smile, 
            Ghost, Cat, Dog, Fish, Bird, Bug, Flower, TreePine, Sun, Moon, Cloud, Flame, 
            Droplets, Rocket, Calendar, History, Award, ArrowDown, Users, BarChart2, Eye, EyeOff,
            ClipboardCopy, Download, TrendingUp, Clock
        } from 'lucide-react';
        import { initializeApp } from 'firebase/app';
        import { 
            getFirestore, collection, addDoc, updateDoc, deleteDoc, increment, 
            arrayUnion, onSnapshot, serverTimestamp, getDocs, doc, getDoc
        } from 'firebase/firestore';

        // --- CONSTANTS ---
        const STEPS_PER_MILE = 2000;
        const TOTAL_GOAL_MILES = 4195;
        const TOTAL_GOAL_STEPS = TOTAL_GOAL_MILES * STEPS_PER_MILE;
        const MAX_USERS = 20;
        const TOTAL_WEEKS = 12;

        const ROUTE_WAYPOINTS = [
            { name: "Seattle, WA", lat: 47.6062, lng: -122.3321, fact: "Start Line! Did you know Seattle has a troll living under the Aurora Bridge?" },
            { name: "San Francisco, CA", lat: 37.7749, lng: -122.4194, fact: "The Golden Gate Bridge's color is officially called 'International Orange'." },
            { name: "Los Angeles, CA", lat: 34.0522, lng: -118.2437, fact: "LA's full name is 'El Pueblo de Nuestra Se√±ora la Reina de los √Ångeles del R√≠o Porci√∫ncula'." },
            { name: "Las Vegas, NV", lat: 36.1699, lng: -115.1398, fact: "The Luxor Las Vegas Sky Beam is the brightest light beam in the world." },
            { name: "Moab, UT", lat: 38.5733, lng: -109.5498, fact: "Moab is home to the stunning arches of Arches National Park." },
            { name: "Denver, CO", lat: 39.7392, lng: -104.9903, fact: "The 13th step of the State Capitol building is exactly one mile above sea level." },
            { name: "Chicago, IL", lat: 41.8781, lng: -87.6298, fact: "The Chicago River is the only river in the world that flows backwards." },
            { name: "Philadelphia, PA", lat: 39.9526, lng: -75.1652, fact: "Philadelphia is home to America's first zoo and first hospital." },
            { name: "New York City, NY", lat: 40.7128, lng: -74.0060, fact: "Finish Line! NYC has more than 800 languages spoken, making it the most linguistically diverse city." }
        ];

        // --- UTILS ---
        function toRad(value) { return (value * Math.PI) / 180; }
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; 
            const dLat = toRad(lat2 - lat1);
            const dLon = toRad(lon2 - lon1);
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(toRad(lat1)) * Math.cos(toRad(lat2));
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }
        function calculateRouteTotalDistance(waypoints) {
            let total = 0;
            for (let i = 0; i < waypoints.length - 1; i++) {
                total += haversineDistance(waypoints[i].lat, waypoints[i].lng, waypoints[i + 1].lat, waypoints[i + 1].lng);
            }
            return total;
        }
        function getPositionAtProgress(waypoints, percentage) {
            if (percentage <= 0) return [waypoints[0].lat, waypoints[0].lng];
            if (percentage >= 1) return [waypoints[waypoints.length - 1].lat, waypoints[waypoints.length - 1].lng];
            const totalDist = calculateRouteTotalDistance(waypoints);
            const targetDist = totalDist * percentage;
            let currentDist = 0;
            for (let i = 0; i < waypoints.length - 1; i++) {
                const segmentDist = haversineDistance(waypoints[i].lat, waypoints[i].lng, waypoints[i + 1].lat, waypoints[i + 1].lng);
                if (currentDist + segmentDist >= targetDist) {
                    const remaining = targetDist - currentDist;
                    const ratio = remaining / segmentDist;
                    const lat = waypoints[i].lat + (waypoints[i + 1].lat - waypoints[i].lat) * ratio;
                    const lng = waypoints[i].lng + (waypoints[i + 1].lng - waypoints[i].lng) * ratio;
                    return [lat, lng];
                }
                currentDist += segmentDist;
            }
            return [waypoints[waypoints.length - 1].lat, waypoints[waypoints.length - 1].lng];
        }

        // --- FIREBASE SETUP ---
        const firebaseConfig = {
          apiKey: "AIzaSyBscaY5kkaXkea9ZFoMeqYNvmCnVEVeTfs",
          authDomain: "tea-and-o-amazing-race.firebaseapp.com",
          projectId: "tea-and-o-amazing-race",
          storageBucket: "tea-and-o-amazing-race.firebasestorage.app",
          messagingSenderId: "138999611724",
          appId: "1:138999611724:web:2698b10f0cff7b3ea74fe9",
          measurementId: "G-B0KZL6PPC3"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const RACERS_COLLECTION = 'racers';
        const LOCAL_STORAGE_KEY = 'tea_o_race_data';
        const listeners = [];
        let unsubscribeSnapshot = null;
        let isOfflineMode = false;

        // --- DATA LAYER ---
        const getLocalUsers = () => {
          try {
            const data = localStorage.getItem(LOCAL_STORAGE_KEY);
            const users = data ? JSON.parse(data) : [];
            return users.map(u => ({
              ...u,
              steps: typeof u.steps === 'number' ? u.steps : 0,
              stepHistory: Array.isArray(u.stepHistory) 
                ? u.stepHistory.map(e => ({ ...e, amount: typeof e.amount === 'number' ? e.amount : 0 }))
                : []
            }));
          } catch { return []; }
        };

        const saveLocalUsers = (users) => {
          localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(users));
          listeners.forEach(cb => cb(users, false));
        };

        const startSnapshotListener = () => {
          if (unsubscribeSnapshot) unsubscribeSnapshot();
          const q = collection(db, RACERS_COLLECTION);
          unsubscribeSnapshot = onSnapshot(q, (snapshot) => {
              isOfflineMode = false;
              const users = snapshot.docs.map(doc => {
                const data = doc.data();
                return {
                    id: doc.id,
                    ...data,
                    steps: typeof data.steps === 'number' ? data.steps : 0,
                    stepHistory: Array.isArray(data.stepHistory) 
                      ? data.stepHistory.map(e => ({ ...e, amount: typeof e.amount === 'number' ? e.amount : 0 }))
                      : []
                };
              });
              localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(users));
              listeners.forEach(cb => cb(users, true));
            }, 
            (error) => {
              console.warn("Firebase Error:", error.message);
              isOfflineMode = true;
              listeners.forEach(cb => cb(getLocalUsers(), false));
            }
          );
        };

        const api = {
          subscribeToUsers(callback) {
            listeners.push(callback);
            if (listeners.length === 1) startSnapshotListener();
            else if (isOfflineMode) callback(getLocalUsers(), false);
            return () => { const idx = listeners.indexOf(callback); if (idx !== -1) listeners.splice(idx, 1); };
          },
          retryConnection() { isOfflineMode = false; startSnapshotListener(); },
          async addUser(name, teamName, iconId) {
            const newUserBase = { name, teamName: teamName || "", iconId, steps: 0, weeklySteps: {}, stepHistory: [] };
            try {
              const docRef = await addDoc(collection(db, RACERS_COLLECTION), { ...newUserBase, createdAt: serverTimestamp() });
              if (isOfflineMode) { isOfflineMode = false; startSnapshotListener(); }
              return { id: docRef.id, ...newUserBase };
            } catch (e) {
              isOfflineMode = true;
              const localUsers = getLocalUsers();
              const newUser = { ...newUserBase, id: `local-${Date.now()}`, createdAt: new Date().toISOString() };
              localUsers.push(newUser);
              saveLocalUsers(localUsers);
              return newUser;
            }
          },
          async addSteps(userId, steps, week) {
            try {
              const userRef = doc(db, RACERS_COLLECTION, userId);
              await updateDoc(userRef, {
                steps: increment(steps),
                [`weeklySteps.${week}`]: increment(steps),
                stepHistory: arrayUnion({ amount: steps, date: new Date().toISOString(), week: week }),
                lastUpdated: serverTimestamp()
              });
              if (isOfflineMode) { isOfflineMode = false; startSnapshotListener(); }
              return { id: userId }; 
            } catch (e) {
              isOfflineMode = true;
              const localUsers = getLocalUsers();
              const user = localUsers.find(u => u.id === userId);
              if (user) {
                user.steps += steps;
                if (!user.weeklySteps) user.weeklySteps = {};
                user.weeklySteps[week] = (user.weeklySteps[week] || 0) + steps;
                if (!user.stepHistory) user.stepHistory = [];
                user.stepHistory.push({ amount: steps, date: new Date().toISOString(), week: week });
                saveLocalUsers(localUsers);
                return user;
              }
              return null;
            }
          },
          async removeStepEntry(userId, entryIndex) {
            try {
              const userRef = doc(db, RACERS_COLLECTION, userId);
              const snap = await getDoc(userRef);
              if (!snap.exists()) throw new Error("User not found");
              const userData = snap.data();
              const history = userData.stepHistory || [];
              if (entryIndex < 0 || entryIndex >= history.length) return false;
              const entryToRemove = history[entryIndex];
              const newHistory = [...history];
              newHistory.splice(entryIndex, 1);
              const currentTotal = userData.steps || 0;
              const newTotal = Math.max(0, currentTotal - entryToRemove.amount);
              const currentWeekly = userData.weeklySteps || {};
              const weekKey = entryToRemove.week || 1;
              const newWeekVal = Math.max(0, (currentWeekly[weekKey] || 0) - entryToRemove.amount);
              await updateDoc(userRef, { steps: newTotal, weeklySteps: { ...currentWeekly, [weekKey]: newWeekVal }, stepHistory: newHistory, lastUpdated: serverTimestamp() });
              return true;
            } catch (e) {
              isOfflineMode = true;
              const localUsers = getLocalUsers();
              const user = localUsers.find(u => u.id === userId);
              if (user && user.stepHistory && user.stepHistory[entryIndex]) {
                  const entry = user.stepHistory[entryIndex];
                  user.steps = Math.max(0, user.steps - entry.amount);
                  if (user.weeklySteps && entry.week) user.weeklySteps[entry.week] = Math.max(0, (user.weeklySteps[entry.week] || 0) - entry.amount);
                  user.stepHistory.splice(entryIndex, 1);
                  saveLocalUsers(localUsers);
                  return true;
              }
              return false;
            }
          },
          async deleteUser(userId) {
            try {
              await deleteDoc(doc(db, RACERS_COLLECTION, userId));
              return true;
            } catch (e) {
              isOfflineMode = true;
              const localUsers = getLocalUsers();
              saveLocalUsers(localUsers.filter(u => u.id !== userId));
              return true;
            }
          },
          async resetRace() {
            localStorage.removeItem(LOCAL_STORAGE_KEY);
            listeners.forEach(cb => cb([], isOfflineMode));
            try {
              const querySnapshot = await getDocs(collection(db, RACERS_COLLECTION));
              await Promise.all(querySnapshot.docs.map(d => deleteDoc(doc(db, RACERS_COLLECTION, d.id))));
            } catch (e) { console.error("Firebase Reset failed", e); }
          }
        };

        // --- COMPONENTS ---

        const DashboardStats = ({ totalSteps, activeUserCount }) => {
          const totalMiles = totalSteps / STEPS_PER_MILE;
          const progressPercent = Math.min((totalSteps / TOTAL_GOAL_STEPS) * 100, 100);
          return (
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
              <div className="bg-white p-6 rounded-2xl border border-gray-100 shadow-sm hover:shadow-md transition-shadow relative overflow-hidden">
                <div className="relative z-10">
                  <h3 className="text-gray-500 text-xs font-bold uppercase tracking-wider">Total Team Steps</h3>
                  <p className="text-4xl font-normal text-gray-800 mt-2">{totalSteps.toLocaleString()}</p>
                  <div className="mt-2 flex items-center gap-2 text-sm text-gray-500">
                     <div className="flex items-center gap-1 bg-blue-50 text-blue-600 px-2 py-0.5 rounded-full text-xs font-bold">
                       <Users size={12} /> {activeUserCount} Racers
                     </div>
                     <span>contributed</span>
                  </div>
                </div>
              </div>
              <div className="bg-white p-6 rounded-2xl border border-gray-100 shadow-sm hover:shadow-md transition-shadow">
                <h3 className="text-gray-500 text-xs font-bold uppercase tracking-wider">Distance Covered</h3>
                <p className="text-4xl font-normal text-gray-800 mt-2">{totalMiles.toFixed(1)} <span className="text-xl text-gray-400">mi</span></p>
                <div className="mt-2 flex items-center text-sm text-gray-400">
                   <span className="text-red-500 font-medium mr-1">Target:</span> {TOTAL_GOAL_MILES.toLocaleString()} mi
                </div>
              </div>
              <div className="bg-white p-6 rounded-2xl border border-gray-100 shadow-sm hover:shadow-md transition-shadow flex flex-col justify-center">
                <div className="flex justify-between items-end mb-3">
                    <h3 className="text-gray-500 text-xs font-bold uppercase tracking-wider">Race Progress</h3>
                    <span className="text-3xl font-normal text-green-600">{progressPercent.toFixed(2)}%</span>
                </div>
                <div className="w-full bg-gray-100 rounded-full h-3 overflow-hidden">
                  <div className="bg-[#34A853] h-3 rounded-full transition-all duration-1000 ease-out" style={{ width: `${progressPercent}%` }}></div>
                </div>
              </div>
            </div>
          );
        };

        const RaceMap = ({ progressPercentage, viewMode }) => {
          const mapContainerRef = useRef(null);
          const mapInstanceRef = useRef(null);
          const markerRef = useRef(null);
          const polylineRef = useRef(null);

          const iconShoe = L.divIcon({
            html: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#EA4335" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3" fill="white"/></svg>`,
            className: 'drop-shadow-md',
            iconSize: [40, 40],
            iconAnchor: [20, 40],
            popupAnchor: [0, -40]
          });

          useEffect(() => {
            if (!mapContainerRef.current) return;
            if (!mapInstanceRef.current) {
              const map = L.map(mapContainerRef.current, { zoomControl: false }).setView([39.8283, -98.5795], 4);
              L.control.zoom({ position: 'bottomright' }).addTo(map);
              L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap' }).addTo(map);
              const latLngs = ROUTE_WAYPOINTS.map(wp => [wp.lat, wp.lng]);
              polylineRef.current = L.polyline(latLngs, { color: '#4285F4', weight: 5, opacity: 0.8 }).addTo(map);
              L.circleMarker([ROUTE_WAYPOINTS[0].lat, ROUTE_WAYPOINTS[0].lng], { color: '#34A853', fillColor: '#34A853', fillOpacity: 1, radius: 6 }).addTo(map).bindPopup("Start: Seattle");
              L.circleMarker([ROUTE_WAYPOINTS[ROUTE_WAYPOINTS.length-1].lat, ROUTE_WAYPOINTS[ROUTE_WAYPOINTS.length-1].lng], { color: '#EA4335', fillColor: '#EA4335', fillOpacity: 1, radius: 6 }).addTo(map).bindPopup("Finish: NYC");
              ROUTE_WAYPOINTS.slice(1, -1).forEach(wp => L.circleMarker([wp.lat, wp.lng], { color: '#FBBC05', fillColor: '#FBBC05', fillOpacity: 1, radius: 4 }).addTo(map).bindPopup(wp.name));
              mapInstanceRef.current = map;
            }
          }, []);

          useEffect(() => {
            if (!mapInstanceRef.current) return;
            const [lat, lng] = getPositionAtProgress(ROUTE_WAYPOINTS, progressPercentage);
            const milesCovered = (progressPercentage * TOTAL_GOAL_MILES).toFixed(1);
            const percentDisplay = (progressPercentage * 100).toFixed(2);
            const popupContent = `<div class="text-center font-sans"><div class="font-bold text-gray-800 text-sm">Current Location</div><div class="text-xs text-gray-500 mt-1">${percentDisplay}% Complete</div><div class="text-sm font-bold text-[#4285F4] mt-1 border-t pt-1 border-gray-100">${milesCovered} miles</div></div>`;

            if (markerRef.current) {
              markerRef.current.setLatLng([lat, lng]);
              markerRef.current.setPopupContent(popupContent);
            } else {
              markerRef.current = L.marker([lat, lng], { icon: iconShoe }).addTo(mapInstanceRef.current);
              markerRef.current.bindPopup(popupContent);
            }
            if (viewMode === 'local') {
              mapInstanceRef.current.flyTo([lat, lng], 13, { duration: 1.5 });
              markerRef.current.openPopup();
            } else {
              mapInstanceRef.current.flyTo([39.8283, -98.5795], 4, { duration: 1.5 });
              markerRef.current.closePopup();
            }
          }, [progressPercentage, viewMode]);

          return <div ref={mapContainerRef} className="h-[450px] w-full rounded-2xl shadow-sm border border-gray-200 z-0 bg-white" />;
        };

        const Leaderboard = ({ users }) => {
          const sortedUsers = [...users].sort((a, b) => (b.steps || 0) - (a.steps || 0));
          const topLeaders = sortedUsers.slice(0, 5);
          const chasers = sortedUsers.slice(5, 10);
          
          const getRankColor = (index) => {
            switch (index) {
              case 0: return 'bg-[#FBBC05] text-white';
              case 1: return 'bg-[#9AA0A6] text-white';
              case 2: return 'bg-[#E37400] text-white';
              default: return 'bg-blue-50 text-blue-600';
            }
          };
          const getDisplayName = (u) => u.teamName ? u.teamName : u.name;
          const getSubtext = (u) => u.teamName ? u.name : null;

          return (
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              {/* Top 5 */}
              <div className="bg-white rounded-2xl border border-gray-100 shadow-sm p-6">
                <div className="flex items-center gap-2 mb-6 border-b border-gray-100 pb-4">
                    <div className="bg-yellow-100 p-2 rounded-full"><Award className="text-[#FBBC05]" size={20} /></div>
                    <h2 className="text-lg font-normal text-gray-800">Leaderboard (Top 5)</h2>
                </div>
                {users.length === 0 ? <p className="text-gray-400 text-center italic py-4">Waiting for racers...</p> : (
                  <ul className="space-y-4">
                    {topLeaders.map((user, index) => (
                      <li key={user.id} className="flex items-center justify-between group">
                        <div className="flex items-center gap-4">
                          <span className={`w-8 h-8 flex items-center justify-center rounded-full text-sm font-bold ${getRankColor(index)}`}>{index + 1}</span>
                          <div><span className="text-gray-700 font-medium text-lg block leading-tight">{getDisplayName(user)}</span>{getSubtext(user) && <span className="text-xs text-gray-400">{getSubtext(user)}</span>}</div>
                        </div>
                        <span className="font-roboto text-gray-900 font-bold">{(user.steps || 0).toLocaleString()}</span>
                      </li>
                    ))}
                  </ul>
                )}
              </div>
              
              {/* Next 5 (The Chase) */}
              <div className="bg-white rounded-2xl border border-gray-100 shadow-sm p-6">
                <div className="flex items-center gap-2 mb-6 border-b border-gray-100 pb-4">
                    <div className="bg-blue-50 p-2 rounded-full"><TrendingUp className="text-[#4285F4]" size={20} /></div>
                    <h2 className="text-lg font-normal text-gray-800">In The Hunt (6-10)</h2>
                </div>
                 {chasers.length === 0 ? <p className="text-gray-400 text-center italic py-4 text-sm">More racers needed to fill the ranks!</p> : (
                  <ul className="space-y-4">
                    {chasers.map((user, index) => (
                      <li key={user.id} className="flex items-center justify-between opacity-90 hover:opacity-100 transition-opacity">
                        <div className="flex items-center gap-4">
                          <span className="w-8 h-8 flex items-center justify-center rounded-full text-sm font-bold bg-gray-100 text-gray-500">{index + 6}</span>
                          <div><span className="text-gray-600 font-medium text-lg block leading-tight">{getDisplayName(user)}</span>{getSubtext(user) && <span className="text-xs text-gray-400">{getSubtext(user)}</span>}</div>
                        </div>
                        <span className="font-roboto text-gray-600 font-medium">{(user.steps || 0).toLocaleString()}</span>
                      </li>
                    ))}
                  </ul>
                )}
              </div>
            </div>
          );
        };

        const TimeBasedLeaderboard = ({ users }) => {
          const [viewMode, setViewMode] = useState('overall');
          const weeksArray = Array.from({ length: TOTAL_WEEKS }, (_, i) => (i + 1).toString());
          const calculateScore = (user) => viewMode === 'overall' ? (user.steps || 0) : (user.weeklySteps ? (user.weeklySteps[viewMode] || 0) : 0);
          const leaders = users.map(user => ({ ...user, currentScore: calculateScore(user) })).sort((a, b) => b.currentScore - a.currentScore).slice(0, 5).filter(u => u.currentScore > 0);
          const getDisplayName = (u) => u.teamName ? u.teamName : u.name;

          return (
            <div className="bg-white rounded-3xl border border-gray-100 shadow-sm p-8 relative overflow-hidden">
              <div className="absolute top-0 right-0 w-64 h-64 bg-gradient-to-bl from-blue-50 to-transparent rounded-bl-full -mr-16 -mt-16 opacity-50" />
              <div className="flex flex-col md:flex-row justify-between items-center mb-6 relative z-10 gap-4">
                <div className="flex items-center gap-3">
                  <div className={`p-3 rounded-full ${viewMode === 'overall' ? 'bg-indigo-100 text-indigo-600' : 'bg-purple-100 text-purple-600'}`}>
                     {viewMode === 'overall' ? <Zap size={24} /> : <Calendar size={24} />}
                  </div>
                  <div><h2 className="text-2xl font-normal text-gray-800">Momentum Tracker</h2><p className="text-gray-500 text-sm">{viewMode === 'overall' ? 'All-time race leaders' : `Top performers for Week ${viewMode}`}</p></div>
                </div>
                <div className="bg-gray-100 p-1.5 rounded-xl flex items-center relative">
                  <select value={viewMode} onChange={(e) => setViewMode(e.target.value)} className="appearance-none bg-white text-gray-800 font-bold py-2 pl-4 pr-10 rounded-lg cursor-pointer focus:outline-none focus:ring-2 focus:ring-purple-500 shadow-sm border-0">
                    <option value="overall">üèÜ Overall Leaders</option>
                    {weeksArray.map(week => <option key={week} value={week}>üìÖ Week {week}</option>)}
                  </select>
                </div>
              </div>
              <div className="grid grid-cols-1 md:grid-cols-5 gap-4 relative z-10">
                {leaders.length === 0 ? <div className="col-span-full py-12 text-center text-gray-400"><Clock className="mx-auto mb-2 opacity-50"/>No activity recorded for this period.</div> : leaders.map((user, index) => (
                  <div key={user.id} className={`flex flex-col items-center p-4 rounded-2xl border ${index === 0 ? 'bg-gradient-to-b from-white to-gray-50 border-gray-200 md:scale-105 z-10' : 'bg-white border-gray-100'}`}>
                     {index === 0 && <div className="mb-2 bg-yellow-100 text-[#f59e0b] px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1"><TrendingUp size={12}/> LEADER</div>}
                     <div className="mb-2"><div className={`w-12 h-12 rounded-full flex items-center justify-center text-lg font-bold ${index === 0 ? 'bg-yellow-100 text-yellow-700' : index === 1 ? 'bg-gray-200 text-gray-700' : index === 2 ? 'bg-orange-100 text-orange-700' : 'bg-blue-50 text-blue-600'}`}>#{index + 1}</div></div>
                     <h3 className="font-bold text-gray-800 text-center leading-tight mb-1 truncate w-full">{getDisplayName(user)}</h3>
                     <p className={`text-xl font-roboto font-bold ${viewMode === 'overall' ? 'text-indigo-600' : 'text-purple-600'}`}>{user.currentScore.toLocaleString()}</p>
                     <p className="text-xs text-gray-400 mt-1 uppercase tracking-wider font-medium">Steps</p>
                  </div>
                ))}
              </div>
            </div>
          );
        };

        const WeeklyAnalytics = ({ users }) => {
            const sortedUsers = useMemo(() => [...users].sort((a, b) => b.steps - a.steps), [users]);
            const [selectedUserIds, setSelectedUserIds] = useState(() => {
                const initial = new Set();
                sortedUsers.slice(0, 5).forEach(u => initial.add(u.id));
                return initial;
            });
            const [hoveredWeek, setHoveredWeek] = useState(null);
            const toggleUser = (id) => {
                const newSet = new Set(selectedUserIds);
                if (newSet.has(id)) newSet.delete(id); else newSet.add(id);
                setSelectedUserIds(newSet);
            };
            const getDisplayName = (u) => u.teamName ? u.teamName : u.name;
            const CHART_COLORS = ['#4285F4', '#EA4335', '#FBBC05', '#34A853', '#8E24AA', '#00ACC1', '#F4511E', '#3949AB', '#D81B60', '#00897B'];
            const weeks = Array.from({ length: TOTAL_WEEKS }, (_, i) => i + 1);
            const CHART_HEIGHT = 200, CHART_WIDTH = 800, PADDING_X = 40, PADDING_Y = 20;

            const maxSteps = useMemo(() => {
                let max = 10000;
                users.forEach(u => {
                    if (!selectedUserIds.has(u.id)) return;
                    if (u.weeklySteps) Object.values(u.weeklySteps).forEach(val => { if (val > max) max = val; });
                });
                return Math.ceil(max / 5000) * 5000;
            }, [users, selectedUserIds]);

            const getX = (i) => PADDING_X + (i * ((CHART_WIDTH - PADDING_X * 2) / (TOTAL_WEEKS - 1)));
            const getY = (v) => CHART_HEIGHT - PADDING_Y - ((v / maxSteps) * (CHART_HEIGHT - PADDING_Y * 2));
            
            const userPaths = useMemo(() => sortedUsers.map((user, index) => {
                if (!selectedUserIds.has(user.id)) return null;
                const points = weeks.map((week, idx) => {
                    const steps = user.weeklySteps?.[week] || 0;
                    if (steps <= 0) return null;
                    return { x: getX(idx), y: getY(steps), value: steps, week };
                }).filter(p => p !== null);
                if (points.length === 0) return null;
                const d = points.map((pt, i) => `${i === 0 ? 'M' : 'L'} ${pt.x},${pt.y}`).join(' ');
                return { userId: user.id, color: CHART_COLORS[index % CHART_COLORS.length], d, points };
            }).filter(p => p !== null), [sortedUsers, selectedUserIds, maxSteps]);

            return (
                <div className="bg-white rounded-3xl border border-gray-100 shadow-sm p-8 mt-8">
                    <div className="flex items-center gap-3 mb-6">
                        <div className="bg-orange-100 p-2 rounded-full text-orange-600"><BarChart2 size={24} /></div>
                        <div><h2 className="text-2xl font-normal text-gray-800">Weekly Performance Analytics</h2></div>
                    </div>
                    <div className="relative w-full h-[250px] overflow-hidden">
                        <svg viewBox={`0 0 ${CHART_WIDTH} ${CHART_HEIGHT}`} className="w-full h-full font-sans text-xs select-none" preserveAspectRatio="none">
                            {[0, 0.5, 1].map(pct => { const val = Math.round(maxSteps * pct); const y = getY(val); return <g key={pct}><line x1={PADDING_X} y1={y} x2={CHART_WIDTH - PADDING_X} y2={y} stroke="#f3f4f6" strokeWidth="1"/><text x={PADDING_X - 5} y={y + 4} textAnchor="end" fill="#9ca3af">{val >= 1000 ? `${val/1000}k` : val}</text></g>; })}
                            {weeks.map((w, i) => <text key={w} x={getX(i)} y={CHART_HEIGHT - 5} textAnchor="middle" fill="#6b7280">W{w}</text>)}
                            {userPaths.map(p => <path key={p.userId} d={p.d} fill="none" stroke={p.color} strokeWidth="2.5" className="transition-all" style={{opacity: hoveredWeek !== null ? 0.3 : 1}} />)}
                            {userPaths.map(p => <g key={`pts-${p.userId}`}>{p.points.map((pt, i) => <circle key={i} cx={pt.x} cy={pt.y} r={hoveredWeek === pt.week ? 6 : 3} fill="white" stroke={p.color} strokeWidth="2" style={{opacity: hoveredWeek !== null && hoveredWeek !== pt.week ? 0.1 : 1}}/>)}</g>)}
                            {weeks.map((w, i) => <rect key={`ov-${w}`} x={getX(i) - 20} y={0} width={40} height={CHART_HEIGHT} fill="transparent" className="cursor-crosshair hover:fill-gray-50/50" onMouseEnter={() => setHoveredWeek(w)} onMouseLeave={() => setHoveredWeek(null)}/>)}
                        </svg>
                        {hoveredWeek !== null && (
                            <div className="absolute top-4 right-4 bg-white/95 backdrop-blur-sm border border-gray-200 p-4 rounded-xl shadow-lg z-10 min-w-[200px] animate-fade-in pointer-events-none">
                                <h4 className="text-gray-500 text-xs font-bold uppercase mb-2">Week {hoveredWeek} Stats</h4>
                                <div className="space-y-1">
                                    {sortedUsers.filter(u => selectedUserIds.has(u.id) && u.weeklySteps?.[hoveredWeek]).map((u, i) => (
                                        <div key={u.id} className="flex items-center justify-between text-sm">
                                            <div className="flex items-center gap-2">
                                                <div className="w-2 h-2 rounded-full" style={{ backgroundColor: CHART_COLORS[sortedUsers.findIndex(su => su.id === u.id) % CHART_COLORS.length] }} />
                                                <span className="text-gray-700 font-medium truncate max-w-[100px]">{getDisplayName(u)}</span>
                                            </div>
                                            <span className="font-mono font-bold text-gray-900">{(u.weeklySteps[hoveredWeek] || 0).toLocaleString()}</span>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                    </div>
                    <div className="mt-8 border-t border-gray-100 pt-6 flex flex-wrap gap-2">
                        {sortedUsers.map((u, i) => {
                            const isSelected = selectedUserIds.has(u.id);
                            return <button key={u.id} onClick={() => toggleUser(u.id)} className={`flex items-center gap-2 px-3 py-1.5 rounded-full text-xs font-medium border transition-all ${isSelected ? 'bg-white border-gray-200 text-gray-800 shadow-sm' : 'bg-gray-50 border-transparent text-gray-400'}`}><div className={`w-2.5 h-2.5 rounded-full ${isSelected ? '' : 'bg-gray-300'}`} style={{ backgroundColor: isSelected ? CHART_COLORS[i % CHART_COLORS.length] : undefined }} />{getDisplayName(u)} {isSelected ? <Eye size={12}/> : <EyeOff size={12}/>}</button>;
                        })}
                    </div>
                </div>
            );
        };

        const ICON_LIBRARY = [
          { id: 'cat', icon: Cat, color: 'bg-orange-100 text-orange-600' },
          { id: 'dog', icon: Dog, color: 'bg-amber-100 text-amber-700' },
          { id: 'bird', icon: Bird, color: 'bg-sky-100 text-sky-600' },
          { id: 'fish', icon: Fish, color: 'bg-blue-100 text-blue-600' },
          { id: 'bug', icon: Bug, color: 'bg-lime-100 text-lime-600' },
          { id: 'flower', icon: Flower, color: 'bg-pink-100 text-pink-600' },
          { id: 'tree', icon: TreePine, color: 'bg-green-100 text-green-700' },
          { id: 'sun', icon: Sun, color: 'bg-yellow-100 text-yellow-600' },
          { id: 'moon', icon: Moon, color: 'bg-indigo-100 text-indigo-600' },
          { id: 'cloud', icon: Cloud, color: 'bg-slate-100 text-slate-600' },
          { id: 'fire', icon: Flame, color: 'bg-red-100 text-red-600' },
          { id: 'water', icon: Droplets, color: 'bg-cyan-100 text-cyan-600' },
          { id: 'zap', icon: Zap, color: 'bg-yellow-200 text-yellow-700' },
          { id: 'star', icon: Star, color: 'bg-purple-100 text-purple-600' },
          { id: 'heart', icon: Heart, color: 'bg-rose-100 text-rose-600' },
          { id: 'trophy', icon: Trophy, color: 'bg-amber-200 text-amber-800' },
          { id: 'crown', icon: Crown, color: 'bg-fuchsia-100 text-fuchsia-600' },
          { id: 'smile', icon: Smile, color: 'bg-teal-100 text-teal-600' },
          { id: 'ghost', icon: Ghost, color: 'bg-gray-200 text-gray-700' },
          { id: 'rocket', icon: Rocket, color: 'bg-violet-100 text-violet-600' },
        ];

        const AddStepsForm = ({ users, onAddSteps, onAddUser, onRemoveUser, onDeleteStep }) => {
          const [selectedUserId, setSelectedUserId] = useState(null);
          const [isCreatingUser, setIsCreatingUser] = useState(false);
          const [stepInput, setStepInput] = useState('');
          const [selectedWeek, setSelectedWeek] = useState(1);
          const [newUserName, setNewUserName] = useState('');
          const [newTeamName, setNewTeamName] = useState('');
          const [selectedIconId, setSelectedIconId] = useState('smile');

          const emptySlotsCount = Math.max(0, MAX_USERS - users.length);
          const emptySlots = Array.from({ length: emptySlotsCount }, (_, i) => i);
          const selectedUser = users.find(u => u.id === selectedUserId);
          const weeksArray = Array.from({ length: TOTAL_WEEKS }, (_, i) => i + 1);

          const handleStepSubmit = (e) => { e.preventDefault(); if (selectedUserId && stepInput) { onAddSteps(selectedUserId, parseInt(stepInput), selectedWeek); setStepInput(''); } };
          const handleCreateUser = (e) => {
